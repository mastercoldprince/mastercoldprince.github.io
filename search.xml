<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>EXT2文件系统</title>
    <url>/2021/11/16/ext2/</url>
    <content><![CDATA[<h1 id="EXT2文件系统"><a href="#EXT2文件系统" class="headerlink" title="EXT2文件系统"></a>EXT2文件系统</h1><p>对文件系统而言，文件仅是一系列可读写的数据块。<br>文件系统不需要了解数据块应该放到物理介质上位置。这些是设备驱动的任务。只要文件系统需要从包含它的块设备中读取信息或数据，它就将请求底层的设备驱动读取一个基本块大小整数倍的数据块。EXT2文件系统将它所使用的逻辑分区划分成数据块组。每个数据块组都将那些对文件系统完整性最重要的信息复制出来，同时将实际文件盒目录看做信息与数据块。<br>文件系统管理的是一个逻辑空间，这个逻辑空间就像一个大的数组，数组的每个元素就是文件系统操作的基本单位——逻辑块。逻辑块是从0开始编号的，而且，逻辑块是连续的，逻辑块相对的是物理块。通常，EXT2的物理块占一个或几个连续的扇区。<br>一般而言，只有块组0的超级块才读入内存，其他块组的超级块仅仅作为备份。在系统运行期间，要将超级块复制到内存系统缓冲区。</p>
<h3 id="块位图和节点位图"><a href="#块位图和节点位图" class="headerlink" title="块位图和节点位图"></a>块位图和节点位图</h3><p>在EXT2文件系统中，采用位图描述数据块和索引节点的使用情况，每个块组中占用两个块，即一个用来描述该数据块的使用情况，另一个描述该组索引节点的使用情况。这两个块分别称为数据位图块和索引节点位图块。数据位图块中的每一位表示该块组中的每一个块的使用情况，如果为0，则表示相应数据块空闲，如果是1，则表示已分配。</p>
<h3 id="索引节点表"><a href="#索引节点表" class="headerlink" title="索引节点表"></a>索引节点表</h3><p>每个块组中的索引节点都存储在各自的索引节点表中，并且按索引节点号依次存储。索引节点表通常占好几个数据块，索引节点表所占的块使用时也想普通的数据块一样被调入块高速缓存。<br><img src="../../../../pics/EXT21.png" alt="图一" title="图一"></p>
<h3 id="数据结构：ext2-super-block"><a href="#数据结构：ext2-super-block" class="headerlink" title="数据结构：ext2_super_block"></a>数据结构：ext2_super_block</h3><p><img src="../../../../pics/EXT22.png"><br><img src="../../../../pics/EXT23.png"></p>
<h3 id="数据结构：ext2-super-info"><a href="#数据结构：ext2-super-info" class="headerlink" title="数据结构：ext2_super_info"></a>数据结构：ext2_super_info</h3><p><img src="../../../../pics/EXT24.png"><br>结构ext2_super_info描述了EXT2文件系统特定的信息。<br>VFS的超级块必须兼容各种文件系统的不同的超级块结构，因此每个文件系统超级块特定的特性必须用另一个结构保存于内存中，以加快对文件的操作。</p>
<h3 id="超级块的操作函数"><a href="#超级块的操作函数" class="headerlink" title="超级块的操作函数"></a>超级块的操作函数</h3><p><img src="../../../../pics/EXT25.png"></p>
<h3 id="EXT2的索引节点inode"><a href="#EXT2的索引节点inode" class="headerlink" title="EXT2的索引节点inode"></a>EXT2的索引节点inode</h3><p>在EXT2文件系统中每个文件与目录由惟一的inode来描述。每个数据块组的EXT2 inode被保存在inode表中，同时还有一个位图被系统用来跟踪已分配和未分配的inode。</p>
<p>EXT2文件系统使用索引节点来记录文件信息。每个普通文件盒目录都有惟一的索引节点与之对应，索引节点中含有文件或目录的重要信息。当你要访问一个文件或目录时，通过文件或目录名首先找到与之对应的索引节点，然后通过索引节点得到文件或目录的信息及磁盘上的具体的存储位置。</p>
<p>###EXT2 文件系统建立过程</p>
<p>在 函数init_ext2_fs注册了EXT2文件系统：<br><img src="../../../../pics/EXT26.png"><br><img src="../../../../pics/EXT27.png"><br>函数ext2_get_sb打开块设备，得到超级块，将这个超级块加到全局super_blocks链表中，并挂接文件系统。<br><img src="../../../../pics/EXT28.png"><br>函数ext2_fill_super从硬盘中读出超级块数据并填充超级块结构</p>
<h3 id="文件的读写"><a href="#文件的读写" class="headerlink" title="文件的读写"></a>文件的读写</h3><p><img src="../../../../pics/EXT29.png"></p>
<p>ext2_aops结构是EXT2 文件系统中具体操作实现函数集<br><img src="../../../../pics/EXT210.png"></p>
<p>ext2_get_block函数是EXT2文件系统特有的，其他都是fs/buffer.c中的函数</p>
<p><img src="../../../../pics/EXT211%E3%80%82png"><br>ext2_get_block()将对文件系统的逻辑块号转换为块设备的逻辑块号。这种转化关系是由ext2_inode结构中i_block[]数组描述的i_block[]的前12项为直接索引表，第13项为间接索引块指针，第14项为二重索引块指针，第15项为三重索引块指针。当文件长度不超过12个块时，可通过直接块索引表直接定位目标块；当文件长度超过12块，并且剩余的部分不超过间接块索引数量时，就在间接块索引块中定位目标块，依次类推。</p>
<p>函数ext2_get_block功能是从逻辑块序号得到对应物理块。若对应物理块被删除，则重新分配，并得到它间接块路径。</p>
<h3 id="ext2-block-to-path"><a href="#ext2-block-to-path" class="headerlink" title="ext2_block_to_path"></a>ext2_block_to_path</h3><p><img src="../../../../pics/EXT212.png"><br>系统是以逻辑块号为索引查找物理块的。例如，要找到第100个逻辑块对应的物理块，因为256+12&gt;100&gt;12，所以要用到一次间接块，在一次间接块中查找第88项，此项内容就是对应的物理块的地址。</p>
<h3 id="ext2-get-branch"><a href="#ext2-get-branch" class="headerlink" title="ext2_get_branch"></a>ext2_get_branch</h3><p>从物理块中读取数据到chain的buffer中<br> inode 操作的节点<br>depth 间接块的深度<br>offset 间接物理块的指针数组<br>chain 存储读取物理块的数据</p>
<h3 id="ext2-alloc-branch"><a href="#ext2-alloc-branch" class="headerlink" title="ext2_alloc_branch"></a>ext2_alloc_branch</h3><p>函数ext2_alloc_branch分配并建立一个块链表，其中参数inode表示需分配块的节点，参数num表示间接块的深度，参数offsets是一个数组，即offsets[num]，参数branch是存储链表的地方。<br><img src="../../../../pics/EXT213.png"><br><img src="../../../../pics/EXT214.png"></p>
]]></content>
      <tags>
        <tag>linux源码</tag>
      </tags>
  </entry>
  <entry>
    <title>关于付灵美师姐的贝叶斯相关问题</title>
    <url>/2021/11/09/hello-world-1/</url>
    <content><![CDATA[<h1 id="第一篇博文是关于如何解决贝叶斯-模糊系统的问题"><a href="#第一篇博文是关于如何解决贝叶斯-模糊系统的问题" class="headerlink" title="第一篇博文是关于如何解决贝叶斯+模糊系统的问题"></a>第一篇博文是关于如何解决贝叶斯+模糊系统的问题</h1><p>已通过修改贝叶斯网络源码解决。待更新最新结果</p>
]]></content>
      <tags>
        <tag>贝叶斯</tag>
        <tag>叉乘</tag>
      </tags>
  </entry>
  <entry>
    <title>操作指南</title>
    <url>/2021/10/21/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>linux系统构建及常用指令</title>
    <url>/2021/11/09/linux_build/</url>
    <content><![CDATA[<h2 id="Linux-2-6内核从配置，到编译，再到安装的命令非常简单，只要按顺序执行下面几个命令就可完成："><a href="#Linux-2-6内核从配置，到编译，再到安装的命令非常简单，只要按顺序执行下面几个命令就可完成：" class="headerlink" title="Linux 2.6内核从配置，到编译，再到安装的命令非常简单，只要按顺序执行下面几个命令就可完成："></a>Linux 2.6内核从配置，到编译，再到安装的命令非常简单，只要按顺序执行下面几个命令就可完成：</h2><h3 id="1-内核配置：make-menuconfig"><a href="#1-内核配置：make-menuconfig" class="headerlink" title="1.内核配置：make menuconfig"></a>1.内核配置：make menuconfig</h3><h4 id="内核配置"><a href="#内核配置" class="headerlink" title="内核配置"></a>内核配置</h4><p>Linux内核在下载解压后需要先配置然后才能编译。源码树的每个目录下都有一个文件Kconfig,这个分布到各目录的Kconfig构成了一个分布式的内核配置数据库，每个Kconfig分别描述了所属目录源文档相关的内核配置菜单。在执行内核配置命令时，从Kconfig中读出菜单的信息供用户进行选择，配置的命令如下：<br>1）make config：基于文本的最为传统的一行一行的配置命令配置，不推荐使用。</p>
<p>2）make menuconfig：基于文本选单的配置界面，字符终端下推荐使用。</p>
<p>3）make xconfig：基于图形窗口模式的配置界面，Xwindow下推荐使用。</p>
<p>2.内核编译：make</p>
<p>3.安装模块：make modules_install</p>
<p>4.安装内核：make install</p>
]]></content>
      <tags>
        <tag>linux使用</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2021/11/17/%E5%85%B3%E4%BA%8E%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
    <content><![CDATA[<h1 id="关于复杂度"><a href="#关于复杂度" class="headerlink" title="关于复杂度"></a>关于复杂度</h1><h2 id="时间复杂度大O记法"><a href="#时间复杂度大O记法" class="headerlink" title="时间复杂度大O记法"></a>时间复杂度大O记法</h2><p>假设每个代码语句每执行一次的耗时是一样的，记为unitTime，所有代码的执行时间，记作T(n)。<br>我们用f(n)来抽象表示一个算法的执行总次数。因此可以推导出所有代码的执行总时间T(n)和每行代码的执行次数n之间的关系是：<br><strong>T(n)=O(f(n))</strong><br>公式中的O表示代码的执行总时间T(n)和其执行总次数f(n)成正比。这种表示法，称之为大O记法。大O记法T(n)=O(f(n))，<strong>表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，表示的是算法的渐近时间复杂度，简称时间复杂度。</strong></p>
<h4 id="例"><a href="#例" class="headerlink" title="例"></a>例</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculateSum</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>; <span class="comment">// 执行一次</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123; <span class="comment">// 循环执行n次</span></span><br><span class="line">        <span class="keyword">int</span> base = i; <span class="comment">// 循环执行n次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123; <span class="comment">// 循环执行n*n次 乘法法则</span></span><br><span class="line">            sum += base + j; <span class="comment">// 循环执行n*n次 乘法法则</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二行代码的时间复杂度是T2(n)=1；第三行、第四行代码的时间复杂度分别是T3(n)=O(n)，T4(n)=O(n)；第五行和第六行代码它们本身会执行n次，但由于是在循环内，所以根据乘法法则，其时间复杂度分别是T5(n)=O(n²)，T6(n)=O(n²)。</p>
<p>最后根据加法法则，整段代码的时间复杂度就是:T(n)=T2(n)+T3(n)+T4(n)+T5(n)+T6(n)=O(1)+O(n)+O(n)+O(n²)+O(n²)=O(2n²+2n+1)</p>
<ul>
<li>加法常数项可以忽略</li>
<li>除去最高阶项，其它次项可以忽略</li>
<li>与最高次项相乘的常数可以忽略</li>
<li>所讲的时间复杂度，一般指的是最坏时间复杂度</li>
</ul>
<h2 id="关于递归的时间复杂度"><a href="#关于递归的时间复杂度" class="headerlink" title="关于递归的时间复杂度"></a>关于递归的时间复杂度</h2>]]></content>
  </entry>
  <entry>
    <title>使用场景分析--打开文件2</title>
    <url>/2021/11/09/%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B62/</url>
    <content><![CDATA[<h1 id="系统调用open"><a href="#系统调用open" class="headerlink" title="系统调用open"></a>系统调用open</h1><h2 id="1-【fs-open-c】sys-open"><a href="#1-【fs-open-c】sys-open" class="headerlink" title="1.【fs/open.c】sys_open()"></a>1.【fs/open.c】sys_open()</h2><p>SYSCALL_DEFINE3(open, const char __user *, filename, int, flags, umode_t, mode)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (force_o_largefile())</span><br><span class="line">        flags |= O_LARGEFILE;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> do_sys_open(AT_FDCWD, filename, flags, mode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SYSCALL_DEFINE3 是用来定义系统调用的宏，展开后类似于这样：<br>sys_open(const char __user *filename, int flags, umode_t mode)，其中filename 实际上就是路径名；flags 表示打开模式，诸如只读、新建等等；mode 代表新建文件的权限，所以仅仅在创建新文件时（flags 为 O_CREAT 或 O_TMPFILE）才使用。参数通过return给传递给 open 的主函数 do_sys_open。</p>
<h2 id="2-【fs-open-c】sys-open-gt-do-sys-open"><a href="#2-【fs-open-c】sys-open-gt-do-sys-open" class="headerlink" title="2.【fs/open.c】sys_open()-&gt;do_sys_open()"></a>2.【fs/open.c】sys_open()-&gt;do_sys_open()</h2><p>在顺利取得空闲的文件表述符的情况下调用 do_filp_open 完成对路径的搜寻和文件的打开，并将文件描述符返回用户空间。</p>
<h2 id="3-【fs-namei-c】sys-open-gt-do-sys-open-gt-getname-gt-getname-flags"><a href="#3-【fs-namei-c】sys-open-gt-do-sys-open-gt-getname-gt-getname-flags" class="headerlink" title="3.【fs/namei.c】sys_open()-&gt;do_sys_open()-&gt;getname()-&gt;getname_flags()"></a>3.【fs/namei.c】sys_open()-&gt;do_sys_open()-&gt;getname()-&gt;getname_flags()</h2><p>在内核缓冲区专用队列里申请一块内存用来放置路径名，若这个字符串已经填满了内存页剩余空间，这时就需要将结构体 struct filename 从这个内存页中分离并单独分配空间，然后用整个内存页保存该字符串。回到 do_sys_open后，为新打开的文件分配空闲文件描述符</p>
<h2 id="【fs-namei-c】sys-open-gt-do-sys-open-gt-do-filp-open"><a href="#【fs-namei-c】sys-open-gt-do-sys-open-gt-do-filp-open" class="headerlink" title="【fs/namei.c】sys_open-&gt;do_sys_open-&gt;do_filp_open"></a>【fs/namei.c】sys_open-&gt;do_sys_open-&gt;do_filp_open</h2><p>path_openat 主要作用是首先为 struct file 申请内存空间，设置遍历路径的初始状态，然后遍历路径并找到最终目标的父节点，最后根据目标的类型和标志位完成 open 操作，最终返回一个新的 file 结构。涉及到“路径行走（path walk）”的两种策略：rcu-walk和 ref-walk。在 rcu-walk 期间将会禁止抢占，也决不能出现进程阻塞，所以其效率很高；ref-walk 会在 rcu-walk 失败、进程需要随眠或者需要取得某结构的引用计数（reference count）的情况下切换进来，很明显它的效率大大低于 rcu-walk。</p>
<h2 id="【fs-namei-c】sys-open-gt-do-sys-open-gt-do-filp-open-gt-path-openat"><a href="#【fs-namei-c】sys-open-gt-do-sys-open-gt-do-filp-open-gt-path-openat" class="headerlink" title="【fs/namei.c】sys_open-&gt;do_sys_open-&gt;do_filp_open-&gt;path_openat"></a>【fs/namei.c】sys_open-&gt;do_sys_open-&gt;do_filp_open-&gt;path_openat</h2><p> total_link_count 用来记录符号链接的深度。最大允许 40 层符号链接。</p>
<h2 id="【fs-namei-c】sys-open-gt-do-sys-open-gt-do-filp-open-gt-path-openat-gt-link-path-walk"><a href="#【fs-namei-c】sys-open-gt-do-sys-open-gt-do-filp-open-gt-path-openat-gt-link-path-walk" class="headerlink" title="【fs/namei.c】sys_open-&gt;do_sys_open-&gt;do_filp_open-&gt;path_openat-&gt;link_path_walk"></a>【fs/namei.c】sys_open-&gt;do_sys_open-&gt;do_filp_open-&gt;path_openat-&gt;link_path_walk</h2><p>找到子目录项path</p>
<h2 id="【fs-namei-c】sys-open-gt-do-sys-open-gt-do-filp-open-gt-path-openat-1"><a href="#【fs-namei-c】sys-open-gt-do-sys-open-gt-do-filp-open-gt-path-openat-1" class="headerlink" title="【fs/namei.c】sys_open &gt; do_sys_open &gt; do_filp_open &gt; path_openat"></a>【fs/namei.c】sys_open &gt; do_sys_open &gt; do_filp_open &gt; path_openat</h2><p>do_last函数会检查最终文件是否存在，以及填充 file 结构<br>最后 may_open 检查相应的权限，然后 finish_open 完成打开操作</p>
]]></content>
      <tags>
        <tag>linux源码</tag>
      </tags>
  </entry>
  <entry>
    <title>文件描述符、文件指针、索引节点</title>
    <url>/2021/11/09/%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E6%8C%87%E9%92%88%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h1 id="文件描述符、文件指针、索引节点"><a href="#文件描述符、文件指针、索引节点" class="headerlink" title="文件描述符、文件指针、索引节点"></a>文件描述符、文件指针、索引节点</h1><h2 id="1、文件描述符-Fd"><a href="#1、文件描述符-Fd" class="headerlink" title="1、文件描述符 Fd"></a>1、文件描述符 Fd</h2><p>当进程打开文件或创建新文件时，内核会返回一个文件描述符（非负整数），用来指向被打开的文件，所有执行I/O操作的系统调用（read、write）都会通过文件描述符。</p>
<p>文件描述符可以理解为进程文件描述表这个表的索引，或者把文件描述表看做一个数组的话，文件描述符可以看做是数组的下标。当需要进行I/O操作的时候，会传入fd作为参数，先从进程文件描述符表查找该fd对应的那个条目，取出对应的那个已经打开的文件的句柄，根据文件句柄指向，去系统fd表中查找到该文件指向的inode，从而定位到该文件的真正位置，从而进行I/O操作。<br><img src="../../pics/Fd.jpg" alt="三张表的关系图" title="三张表的关系图"><br>**特点:<br>**<br>每个文件描述符会与一个打开的文件相对应<br>不同的文件描述符也可能指向同一个文件<br>相同的文件可以被不同的进程打开，也可以在同一个进程被多次打开</p>
<h2 id="2、系统级的文件描述符表"><a href="#2、系统级的文件描述符表" class="headerlink" title="2、系统级的文件描述符表"></a>2、系统级的文件描述符表</h2><p>内核对系统所有打开的文件维护了一个打开文件表，表中每一项称为打开文件句柄，一个打开文件句柄描述了一个打开文件的全部信息</p>
<ul>
<li>当前文件偏移量（调用read()和write()时更新，或使用lseek()直接修改）</li>
<li>打开文件时所使用的状态标识（即，open()的flags参数）</li>
<li>文件访问模式（如调用open()时所设置的只读模式、只写模式或读写模式）</li>
<li>与信号驱动相关的设置</li>
<li>对该文件i-node对象的引用</li>
<li>文件类型（例如：常规文件、套接字或FIFO）和访问权限</li>
<li>一个指针，指向该文件所持有的锁列表</li>
<li>文件的各种属性，包括文件大小以及与不同类型操作相关的时间戳<h2 id="3、文件系统的inode表"><a href="#3、文件系统的inode表" class="headerlink" title="3、文件系统的inode表"></a>3、文件系统的inode表</h2>每个文件系统会为存储于其上的所有文件维护一个inode表<br>文件描述符表、打开文件表、inode表之间的关系：<br><img src="../../pics/Fdbetween.jpg" alt="三者之间的关系" title="三者之间的关系"><br>进程A文件描述符1和20指向同一个打开文件句柄，是因为多次调用open()等函数打开同一个文件导致。<br>进程A的文件描述符2和进程B的文件描述符2指向同一个打开文件句柄可能是因为调用fork()后出现的，子进程会继承父进程的打开文件描述符表，也就是子进程继承父进程打开文件。；或者某进程通过unix域套接字将一个打开的文件描述符传递给另一个进程；或者不通进程独自调用open函数打开同一个文件是正好分配到与其他进程打开该文件描述符一样。<br>进程A的描述符0和进程B的描述符3分别指向不同的打开文件句柄，但这些句柄均指向i-node表的相同条目，即同一个文件，发生这种情况是因为每个进程各自对同一个文件发起了open()调用。同一个进程两次打开同一个文件，也会发生类似情况。<h2 id="补充：磁盘结构"><a href="#补充：磁盘结构" class="headerlink" title="补充：磁盘结构"></a>补充：磁盘结构</h2>文件储存在硬盘上，硬盘的最小存储单位叫做”扇区”（Sector）。每个扇区储存512字节（相当于0.5KB）。<br>操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个”块”（block）。这种由多个扇区组成的”块”，是文件存取的最小单位。”块”的大小，最常见的是4KB，即连续八个 sector组成一个 block。<br><img src="../../pics/Sector.png" alt="扇区" title="扇区"><br><img src="../../pics/Sector2.png" alt="扇区2" title="扇区2"><br><img src="../../pics/Sector3.png" alt="扇区3" title="扇区3"><br>由上，可用（柱面号，盘面号，扇区号）来定位任意一个“磁盘块”，我们经常提到文件数据存放在外存中的几号块（逻辑地址），这个块号就可以转换成（柱面号，盘面号，扇区号）的地址形式。<br>可根据该地址读取一个“块”，操作如下：<br>① 根据“柱面号”移动磁臂，让磁头指向指定柱面（也称磁道）<br>② 激活指定盘面对应的磁头；<br>③ 磁盘旋转的过程中，指定的扇区会从磁头下面划过，这样就完成了对指定扇区的读/写</li>
</ul>
]]></content>
      <tags>
        <tag>linux源码</tag>
      </tags>
  </entry>
  <entry>
    <title>文件系统详解</title>
    <url>/2021/11/09/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="文件系统详解–从操作系统角度来说"><a href="#文件系统详解–从操作系统角度来说" class="headerlink" title="文件系统详解–从操作系统角度来说"></a>文件系统详解–从操作系统角度来说</h1><p>在UNIX系统中，把一切资源都看作是文件，包括硬件设备。UNIX系统把每个硬件都看成是一个文件，通常称为设备文件，这样用户就可以用读写文件的方式实现对硬件的访问。<br>         <strong>UNIX 权限模型也是围绕文件的概念来建立的，所以对设备也就可以同样处理了。</strong><br><img src="../../pics/operator.png" alt="图片" title="图片"></p>
<ol>
<li>硬盘驱动</li>
</ol>
<p>  常见的硬盘类型有PATA, SATA和AHCI等，在Linux系统中，对不同硬盘所提供的驱动模块一般都存放在内核目录树drivers/ata中，而对于一般通用的硬盘驱动，也许会直接被编译到内核中，而不会以模块的方式出现，可以通过查看/boot/config-xxx.xxx文件来确认：</p>
<p>  CONFIG_SATA_AHCI=y</p>
<ol start="2">
<li>General Block Device Layer</li>
</ol>
<p>  这一层的作用，正是解答了上面提出的第一个问题，不同的硬盘驱动，会提供不同的IO接口，内核认为这种杂乱的接口，不利于管理，需要把这些接口抽象一下，形成一个统一的对外接口，这样，不管你是什么硬盘，什么驱动，对外而言，它们所提供的IO接口没什么区别，都一视同仁的被看作块设备来处理。</p>
<p>  所以，如果在一层做的任何修改，将会直接影响到所有文件系统，不管是ext3,ext4还是其它文件系统，只要在这一层次做了某种修改，对它们都会产生影响。</p>
<ol start="3">
<li>文件系统</li>
</ol>
<p>  文件系统这一层相信大家都再熟悉不过了，目前大多Linux发行版本默认使用的文件系统一般是ext4，另外，新一代的btrfs也呼之欲出，不管什么样的文件系统，都是由一系列的mkfs.xxx命令来创建，如：</p>
<p>  mkfs.ext4 /dev/sda</p>
<p>  mkfs.btrfs /dev/sdb</p>
<p>  内核所支持的文件系统类型，在内核目录树 fs 目录中。</p>
<ol start="4">
<li>虚拟文件系统(VFS)</li>
</ol>
<p>  Virtual File System这一层，正是用来解决上面提出的第二个问题，试想，当我们通过mkfs.xxx系列命令创建了很多不同的文件系统，但这些文件系统都有各自的API接口，而用户想要的是，不管你是什么API，他们只关心mount/umount，或open/close等操作。<br>  所以，VFS就把这些不同的文件系统做一个抽象，提供统一的API访问接口，这样，用户空间就不用关心不同文件系统中不一样的API了。VFS所提供的这些统一的API，再经过System Call包装一下，用户空间就可以经过SCI的系统调用来操作不同的文件系统。<br>  VFS所提供的常用API有：<br>  mount()， umount() …<br>  open()，close() …<br>  mkdir() …<br><img src="../../pics/operator2" alt="图片" title="图片"><br>Linux启动时，第一个必须挂载的是根文件系统；若系统不能从指定设备上挂载根文件系统，则系统会出错而退出启动。之后可以自动或手动挂载其他的文件系统。因此，一个系统中可以同时存在不同的文件系统。<br>　　不同的文件系统类型有不同的特点，因而根据存储设备的硬件特性、系统需求等有不同的应用场合。在嵌入式Linux应用中，主要的存储设备为RAM(DRAM, SDRAM)和ROM(常采用FLASH存储器)，常用的基于存储设备的文件系统类型包括：jffs2, yaffs, cramfs, romfs, ramdisk, ramfs/tmpfs等。</p>
]]></content>
      <tags>
        <tag>linux源码</tag>
      </tags>
  </entry>
  <entry>
    <title>使用场景分析--打开文件</title>
    <url>/2021/11/09/%E5%A6%82%E4%BD%95%E6%89%93%E5%BC%80%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="LINUX系统调用源码分析"><a href="#LINUX系统调用源码分析" class="headerlink" title="LINUX系统调用源码分析"></a>LINUX系统调用源码分析</h1><h3 id="关于open函数"><a href="#关于open函数" class="headerlink" title="关于open函数"></a>关于open函数</h3><p>open函数主要包含以下两类：</p>
<p>int open(const char *pathName, int flags); // 打开文件<br>int open(const char *pathName, int flags, mode_t mode); <em>// 创建文件</em><br>open函数做了两件事：<br>将用户进程 task_struct（进程结构） 中的filp[20] 与内核中的file_table[64] 进行挂接。<br>将用户进程需要打开的文件对应的inode节点在file_table[64] 中进行登记。</p>
<ul>
<li>操作系统根据用户进程的需求来操作文件，内核通过 *filp[20] 掌控每一个进程可以打开的文件，既可以打开多个不同的文件，也可以多次打开同一个文件，每打开一次文件（不论是否是同一个文件），就要在 *filp[20] 占用一个项记录指针，所以每一个进程可以同时打开文件的次数不能超过20次；</li>
<li>操作系统中的file_table[64] 是管理所有进程打开文件的数据结构， 不但记录了不同进程打开不同的文件，也记录了不同进程打开同一个文件，甚至记录了同一个进程多次打开一个文件。与filp[20] 类似，只要打开一次文件，就要在file_table[64] 中记录；</li>
<li>文件中的i节点是记载文件属性的最关键的数据结构，在操作系统中i节点和文件是一一对应的，找到i节点，就意味着找到唯一的文件。内核通过inode_table[32] 掌控正在使用的文件i节点，每个被使用的文件i节点都要记录在其中。</li>
</ul>
<p>*<em>打开文件的本质就是要建立 <em>filp[20] file_table[64] inode_table[32] 三者之间的关系。</em></em></p>
<p><img src="../../pics/flip.png" alt="关系" title="关系"></p>
<h3 id="关于打开文件"><a href="#关于打开文件" class="headerlink" title="关于打开文件"></a>关于打开文件</h3><p>Linux中打开文件是通过open系统调用实现，其函数中调用了do_sys_open()函数完成打开功能，首先先看下open系统调用的入口函数，再具体看do_sys_open()函数：</p>
<p>SYSCALL_DEFINE3(open, const char __user *, filename, int, flags, int, mode)</p>
<p>{<br>         long ret;</p>
<pre><code>     if (force_o_largefile())
               flags |= O_LARGEFILE;

     ret = do_sys_open(AT_FDCWD, filename, flags, mode);
     /* avoid REGPARM breakage on x86: */
     asmlinkage_protect(3, ret, filename, flags, mode);
     return ret;
</code></pre>
<p>}</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">do_sys_open</span><span class="params">(<span class="keyword">int</span> dfd, <span class="keyword">const</span> <span class="keyword">char</span> __user *filename, <span class="keyword">int</span> flags, <span class="keyword">int</span> mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*获取文件名称，由getname()函数完成，其内部首先创建存取文件名称的空间，然后*从用户空间把文件名拷贝过来*/</span></span><br></pre></td></tr></table></figure>

<pre><code>     char *tmp = getname(filename);
     int fd = PTR_ERR(tmp);

     if (!IS_ERR(tmp)) &#123;
</code></pre>
<p>/<em>获取一个可用的fd，此函数调用alloc_fd()函数从fd_table中获取一个可用fd,并做些简单初始化，此函数内部实现比较简单，此次分析不细看</em>/</p>
<pre><code>               fd = get_unused_fd_flags(flags);
               if (fd &gt;= 0) &#123;
</code></pre>
<p>/<em>fd获取成功则开始打开文件，此函数是主要完成打开功能的函数</em>/</p>
<pre><code>                        struct file *f = do_filp_open(dfd, tmp, flags, mode, 0);
                        if (IS_ERR(f)) &#123;
                                 /*打开失败，释放fd*/
                                 put_unused_fd(fd);
                                 fd = PTR_ERR(f);
                        &#125; else &#123;
                                 /*文件如果已经被打开了，调用fsnotify_open()函数*/
                                 fsnotify_open(f-&gt;f_path.dentry);
                                 /*将文件指针安装在fd数组中*/
                                 fd_install(fd, f);
                        &#125;
               &#125;
               /*释放放置从用户空间拷贝过来的文件名的存储空间*/
               putname(tmp);
     &#125;
     return fd;&#125;
</code></pre>
<p>打开功能的真正实现功能的函数do_filp_open()函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">struct file *<span class="title">do_filp_open</span><span class="params">(<span class="keyword">int</span> dfd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">int</span> open_flag, <span class="keyword">int</span> mode, <span class="keyword">int</span> acc_mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">         <span class="comment">/*改变参数flag的值，具体做法是flag+1*/</span></span><br><span class="line">         <span class="keyword">int</span> flag = open_to_namei_flags(open_flag);</span><br><span class="line">         <span class="keyword">int</span> force_reval = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">         <span class="comment">/*根据__O_SYNC标志来设置O_DSYNC 标志，用以防止恶意破坏程序*/</span></span><br><span class="line">         <span class="keyword">if</span> (open_flag &amp; __O_SYNC)</span><br><span class="line">                   open_flag |= O_DSYNC;</span><br><span class="line">         <span class="comment">/*设置访问权限*/</span></span><br><span class="line">         <span class="keyword">if</span> (!acc_mode)</span><br><span class="line">                   acc_mode = MAY_OPEN | ACC_MODE(open_flag);</span><br><span class="line"> </span><br><span class="line">         <span class="comment">/*根据 O_TRUNC标志设置写权限 */</span></span><br><span class="line">         <span class="keyword">if</span> (flag &amp; O_TRUNC)</span><br><span class="line">                   acc_mode |= MAY_WRITE;</span><br><span class="line"> </span><br><span class="line">         <span class="comment">/* 设置O_APPEND 标志*/</span></span><br><span class="line">         <span class="keyword">if</span> (flag &amp; O_APPEND)</span><br><span class="line">                   acc_mode |= MAY_APPEND;</span><br><span class="line"> </span><br><span class="line">         <span class="comment">/*如果不是创建文件*/</span></span><br><span class="line">         <span class="keyword">if</span> (!(flag &amp; O_CREAT)) &#123;</span><br><span class="line">                   <span class="comment">/*返回特定的file结构体指针*/</span></span><br><span class="line">                   filp = get_empty_filp();</span><br><span class="line"> </span><br><span class="line">                   <span class="keyword">if</span> (filp == <span class="literal">NULL</span>)</span><br><span class="line">                            <span class="keyword">return</span> ERR_PTR(-ENFILE);</span><br><span class="line">                   <span class="comment">/*填充nameidata 结构*/</span></span><br><span class="line">                   nd.intent.open.file = filp;</span><br><span class="line">                   filp-&gt;f_flags = open_flag;</span><br><span class="line">                   nd.intent.open.flags = flag;</span><br><span class="line">                   nd.intent.open.create_mode = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>当内核要访问一个文件的时候，第一步要做的是找到这个文件，而查找文件的过程在vfs里面是由path_lookup或者path_lookup_open函数来完成的。这两个函数将用户传进来的字符串表示的文件路径转换成一个dentry结构，并建立好相应的inode和file结构，将指向file的描述符返回用户。用户随后通过文件描述符，来访问这些数据结构<br>                   error = do_path_lookup(dfd, pathname,</p>
<pre><code>                                           lookup_flags(flag)|LOOKUP_OPEN, &amp;nd);

               if (IS_ERR(nd.intent.open.file)) &#123;

                        if (error == 0) &#123;

                                 error = PTR_ERR(nd.intent.open.file);

                                 /*减少dentry和vsmount得计数*/

                                 path_put(&amp;nd.path);

                        &#125;

               &#125; else if (error)

                        /*如果查找失败则释放一些资源*/

                        release_open_intent(&amp;nd);

               if (error)

                        return ERR_PTR(error);

               goto ok;

     &#125;



     /*到此则是要创建文件*/
</code></pre>
<p>reval:</p>
<pre><code>     /* path-init为查找作准备工作，path_walk真正上路查找，这两个函数联合起来根据一段路径名找到对应的dentry */

     error = path_init(dfd, pathname, LOOKUP_PARENT, &amp;nd);

     if (error)

               return ERR_PTR(error);

     if (force_reval)

               nd.flags |= LOOKUP_REVAL;
</code></pre>
<p>/*这个函数相当重要，就如源代码注释的那样，是整个NFS的名字解析函数，其实也是NFS得以构筑的函数该函数采用一个for循环，对name路径根据目录的层次，一层一层推进，直到终点或失败。在推进的过程中，一步步建立了目录树的dentry和对应的inode */</p>
<pre><code>     error = path_walk(pathname, &amp;nd);

     if (error) &#123;

               if (nd.root.mnt)

                        path_put(&amp;nd.root);

               return ERR_PTR(error);

     &#125;

     if (unlikely(!audit_dummy_context()))

               /*保存inode节点信息*/

               audit_inode(pathname, nd.path.dentry);



     /*父节点信息*/

     error = -EISDIR;

     if (nd.last_type != LAST_NORM || nd.last.name[nd.last.len])

               goto exit_parent;



     error = -ENFILE;

     /*获取文件指针*/

     filp = get_empty_filp();

     if (filp == NULL)

               goto exit_parent;

     /*填充nameidata 结构*/

     nd.intent.open.file = filp;

     filp-&gt;f_flags = open_flag;

     nd.intent.open.flags = flag;

     nd.intent.open.create_mode = mode;

     dir = nd.path.dentry;

     nd.flags &amp;= ~LOOKUP_PARENT;

     nd.flags |= LOOKUP_CREATE | LOOKUP_OPEN;

     if (flag &amp; O_EXCL)

               nd.flags |= LOOKUP_EXCL;

     mutex_lock(&amp;dir-&gt;d_inode-&gt;i_mutex);

     /*从哈希表中查找nd对应的dentry*/

     path.dentry = lookup_hash(&amp;nd);

     path.mnt = nd.path.mnt;
</code></pre>
<p>do_last:</p>
<pre><code>     error = PTR_ERR(path.dentry);

     if (IS_ERR(path.dentry)) &#123;

               mutex_unlock(&amp;dir-&gt;d_inode-&gt;i_mutex);

               goto exit;

     &#125;



     if (IS_ERR(nd.intent.open.file)) &#123;

               error = PTR_ERR(nd.intent.open.file);

               goto exit_mutex_unlock;

     &#125;



     /*如果此dentry结构没有对应的inode节点，说明是无效的，应该创建文件节点 */

     if (!path.dentry-&gt;d_inode) &#123;

               /*write权限是必需的*/

               error = mnt_want_write(nd.path.mnt);

               if (error)

                        goto exit_mutex_unlock;

               /*按照namei格式的flag open*/

               error = __open_namei_create(&amp;nd, &amp;path, flag, mode);

               if (error) &#123;

                        mnt_drop_write(nd.path.mnt);

                        goto exit;

               &#125;

               /*根据nameidata 得到相应的file结构*/

               filp = nameidata_to_filp(&amp;nd);

               /*放弃写权限*/

               mnt_drop_write(nd.path.mnt);

               if (nd.root.mnt)

                        /*计数减一*/

                        path_put(&amp;nd.root);

               if (!IS_ERR(filp)) &#123;

                        error = ima_file_check(filp, acc_mode);

                        if (error) &#123;

                                 fput(filp);

                                 filp = ERR_PTR(error);

                        &#125;

               &#125;

               return filp;

     &#125;



     /*要打开的文件已经存在*/

     mutex_unlock(&amp;dir-&gt;d_inode-&gt;i_mutex);

     /*保存inode节点*/

     audit_inode(pathname, path.dentry);
</code></pre>
<p>/*</p>
<pre><code>     *省略若干flag标志检查代码

     */



     /*路径装化为相应的nameidata 结构*/

     path_to_nameidata(&amp;path, &amp;nd);

     error = -EISDIR;

     /*如果是文件夹*/

     if (S_ISDIR(path.dentry-&gt;d_inode-&gt;i_mode))

               goto exit;
</code></pre>
<p>ok:</p>
<pre><code>     /*检测是否截断文件标志*/

     will_truncate = open_will_truncate(flag, nd.path.dentry-&gt;d_inode);

     if (will_truncate) &#123;

     /*要截断的话就要获取写权限*/

               error = mnt_want_write(nd.path.mnt);

               if (error)

                        goto exit;

     &#125;

     //may_open执行权限检测、文件打开和truncate的操作

     error = may_open(&amp;nd.path, acc_mode, flag);

     if (error) &#123;

               if (will_truncate)

                        mnt_drop_write(nd.path.mnt);

               goto exit;

     &#125;

     filp = nameidata_to_filp(&amp;nd);

     if (!IS_ERR(filp)) &#123;

               error = ima_file_check(filp, acc_mode);

               if (error) &#123;

                        fput(filp);

                        filp = ERR_PTR(error);

               &#125;

     &#125;

     if (!IS_ERR(filp)) &#123;

               if (acc_mode &amp; MAY_WRITE)

                        vfs_dq_init(nd.path.dentry-&gt;d_inode);



               if (will_truncate) &#123;

                        //处理截断

                        error = handle_truncate(&amp;nd.path);

                        if (error) &#123;

                                 fput(filp);

                                 filp = ERR_PTR(error);

                        &#125;

               &#125;

     &#125;

     //安全的放弃写权限

     if (will_truncate)

               mnt_drop_write(nd.path.mnt);

     if (nd.root.mnt)

               path_put(&amp;nd.root);

     return filp;
</code></pre>
<p>exit_mutex_unlock:</p>
<pre><code>     mutex_unlock(&amp;dir-&gt;d_inode-&gt;i_mutex);
</code></pre>
<p>exit_dput:</p>
<pre><code>     path_put_conditional(&amp;path, &amp;nd);
</code></pre>
<p>exit:</p>
<pre><code>     if (!IS_ERR(nd.intent.open.file))

               release_open_intent(&amp;nd);
</code></pre>
<p>exit_parent:</p>
<pre><code>     if (nd.root.mnt)

               path_put(&amp;nd.root);

     path_put(&amp;nd.path);

     return ERR_PTR(error);
</code></pre>
<p>//允许遍历连接文件，则手工找到连接文件对应的文件</p>
<p>do_link:</p>
<pre><code>     error = -ELOOP;

     if (flag &amp; O_NOFOLLOW)

               //不允许遍历连接文件，返回错误

               goto exit_dput;

     /*

      以下是手工找到链接文件对应的文件dentry结构代码

      */

     // 设置查找LOOKUP_PARENT标志

     nd.flags |= LOOKUP_PARENT;

     //判断操作是否安全

     error = security_inode_follow_link(path.dentry, &amp;nd);

     if (error)

               goto exit_dput;

     // 处理符号链接

     error = __do_follow_link(&amp;path, &amp;nd);

     path_put(&amp;path);

     if (error) &#123;

    

               release_open_intent(&amp;nd);

               if (nd.root.mnt)

                        path_put(&amp;nd.root);

               if (error == -ESTALE &amp;&amp; !force_reval) &#123;

                        force_reval = 1;

                        goto reval;

               &#125;

               return ERR_PTR(error);

     &#125;

     nd.flags &amp;= ~LOOKUP_PARENT;

     // 检查最后一段文件或目录名的属性情况

     if (nd.last_type == LAST_BIND)

               goto ok;

     error = -EISDIR;

     if (nd.last_type != LAST_NORM)

               goto exit;

     if (nd.last.name[nd.last.len]) &#123;

               __putname(nd.last.name);

               goto exit;

     &#125;

     error = -ELOOP;

     // 出现回环标志: 循环超过32次

     if (count++==32) &#123;

               __putname(nd.last.name);

               goto exit;

     &#125;

     dir = nd.path.dentry;

     mutex_lock(&amp;dir-&gt;d_inode-&gt;i_mutex);

     // 更新路径的挂接点和dentry

     path.dentry = lookup_hash(&amp;nd);

     path.mnt = nd.path.mnt;

     __putname(nd.last.name);

     goto do_last;
</code></pre>
<p>}</p>
<p>分析完上述主要函数以后，我们来看一下整个打开流程是如何做到的：</p>
<p>在内核中要打开一个文件，首先应该找到这个文件，而查找文件的过程在vfs里面是由do_path_lookup或者path_lookup_open函数来完成的。这两个函数将用户传进来的字符串表示的文件路径转换成一个dentry结构，并建立好相应的inode和file结构，将指向file的描述符返回用户。用户随后通过文件描述符，来访问这些数据结构。</p>
<p>基本函数流程及调用方式如下所示：</p>
<p>打开过程首先是open系统调用访问SYSCALL_DEFINE3函数，然后调用do_sys_open 函数完成主要功能，再调用函数do_filp_open完成主要的打开功能，下面详细看下do_filp_open中调用的do_path_lookup主要过程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">staic <span class="keyword">int</span>  <span class="title">do_path_lookup</span><span class="params">(<span class="keyword">int</span> dfd,<span class="keyword">const</span> <span class="keyword">char</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">*name,<span class="keyword">unsigned</span> <span class="keyword">int</span> flags,strucy nameidata *nd)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">int</span> retval=path_init(dfd,name,flags,nd);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置nd-&gt;root=根路径（绝对地址）或者当前工作目录（相对地址） 。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这一步做完了后，内核会建立一些数据结构（dentry,inode）来初始化查找的起点</span></span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span>(!retval)</span><br><span class="line"></span><br><span class="line">                       retval = path_walk(name,nd);</span><br><span class="line"></span><br><span class="line"><span class="comment">//path_walk,会遍历路径的每一份量，也就是用“/”分隔开的每一部分，</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//最中找到name指向的文件，walk的意思就是walk path的每一个组分（component）</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们进一步看看path_walk</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">path_walk</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name,struct nameidata *nd)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> link_path_walk(name,nd);</span><br><span class="line"></span><br><span class="line"><span class="comment">//path_walk其实相当于直接调用link_path_walk来完成工作</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">link_path_walk的主要工作是有其内部函数__link_path_walk 来完成的</span><br><span class="line"></span><br><span class="line">          result = __link_path_walk(name,nd)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>至此我们转向最重要的代码__link_walk_path,该函数把传进来的字符串name，也就是用户指定的路径，按路径分隔符分解成一系列小的component。比如用户说，我要找/path/to/dest这个文件，那么我们的文件系统就会按path,to,dest一个一个来找，知道最后一个分量是文件或者查找完成。他找的时候，会先用path_init初始化过的根路径去找第一个分量，也就是path。然后用path的dentry-&gt;d_inode去找to，这样循环到最后一个。注意，内核会缓存找到的路径分量，所以往往只有第一次访问一个路径的时候，才会去访问磁盘，后面的访问会直接从缓存里找，下面会看到，很多与页告诉缓存打交道的代码。但不管怎样，第一遍查找总是会访问磁盘的。</p>
<p>static int __link_path_walk(const char *name,strucy</p>
<p>nameidata *nd)</p>
<p>{</p>
<p>}</p>
<p>至此，按照每一个component查找完成之后，就会找到相应的文件，然后相应的打开工作就基本完成了。</p>
<h3 id="关于文件分类"><a href="#关于文件分类" class="headerlink" title="关于文件分类"></a>关于文件分类</h3><ol>
<li><p>系统的启动和初始化<br> 在基于Intel的系统上，当 loadlin.exe 或 LILO把内核装入到内存并把控制权传递给内核时，内核开始启动。关于这一部分，看arch/i386/kernel/head.S ，head.S进行特定结构的设置，然后跳转到init/main.c的main()例程。</p>
</li>
<li><p>内存管理<br> 内存管理的代码主要在/mm，但特定结构的代码在arch/*/mm。缺页中断处理的代码在mm/memory.c ，而内存映射和页高速缓存器的代码在mm/filemap.c。缓冲器高速缓存是在mm/buffer.c 中实现，而交换高速缓存是在mm/swap_state.c 和mm/swapfile.c中实现。</p>
</li>
<li><p>内核<br>  内核中，特定结构的代码在arch/*/kernel，调度程序在kernel/sched.c，fork的代码在kernel/fork.c，task_struct 数据结构在 include/linux/sched.h中。</p>
</li>
<li><p>PCI</p>
<pre><code>PCI 伪驱动程序在 drivers/pci/pci.c ，其定义在include/linux/pci.h。每一种结构都有一些特定的 PCI BIOS 代码， Intel的在arch/alpha/kernel/bios32.c。
</code></pre>
</li>
<li><p>进程间通信<br>所有System V IPC 对象权限都包含在 ipc_perm 数据结构中，这可以在  include/linux/ipc.h中找到。 System V 消息是在 ipc/msg.c中实现, 共享内存在 ipc/shm.c中，信号量在  ipc/sem.c中，管道在 ipc/pipe.c中实现。</p>
</li>
<li><p>中断处理<br> 内核的中断处理代码是几乎所有的微处理器所特有的。中断处理代码在  arch/i386/kernel/irq.c中，其定义子在 include/asm-i386/irq.h中。</p>
</li>
<li><p>设备驱动程序</p>
<pre><code>Linux内核源代码的很多行是设备驱动程序。Linux设备驱动程序的所有源代码都保存在/driver，根据类型可进一步划分为：
</code></pre>
</li>
</ol>
<p>/block<br>     块设备驱动程序如ide(在ide.c)。如果你想看包含文件系统的所有设备是如何被初始化的，你应当看drivers/block/genhd.c中的device_setup()，device_setup()不仅初始化了硬盘，当一个网络安装nfs文件系统时，它也初始化网络。块设备包含了基于IDE和SCSI的设备。</p>
<p>/char<br>       这是看字符设备(如tty，串口及鼠标等)驱动程序的地方。<br>/cdrom<br>        Linux的所有CDROM代码都在这儿，如在这儿可以找到Soundblaster CDROM的驱动程序。注意ide CD的驱动程序是 ide-cd.c，放在drivers/block，SCSI CD的驱动程序是scsi.c，放在drivers/scsi。<br>/pci<br>    这是PCI伪驱动程序的源代码，在这里可以看到PCI子系统是如何被映射和初始化的。<br>/scsi<br>     在这里可以找到所有的SCSI代码及Linux所支持的scsi设备的所有设备驱动程序。<br>/net<br>    在这里可以找到网络设备驱动程序，如DECChip 21040 PCI 以太网驱动程序在tulip.c中。<br>/sound<br>       这是所有声卡驱动程序的所在地。<br>       8.文件系统<br>   EXT2 文件系统的源代码全部在  fs/ext2/ 目录下，而其数据结构的定义在  include/linux/ext2_fs.h, ext2_fs_i.h 及 ext2_fs_sb.h中。 虚拟文件系统的数据结构在 include/linux/fs.h中描述，而代码是在fs/*中。 缓冲区高速缓存与更新内核的守护进程的实现是在 fs/buffer.c中 。<br>       9.网络<br>   网络代码保存在/net中，大部分的include文件在include/net下，BSD套节口代码在net/socket.c中，IP 第4版本的套节口代码在net/ipv4/af_inet.c。一般的协议支持代码(包括sk_buff 处理例程)在net/core下，TCP/IP联网代码在net/ipv4下，网络设备驱动程序在/drivers/net下。<br>    10.模块<br>   内核模块的代码部分在内核中，部分在模块包中，前者全部在kernel/modules.c中，而数据结构和内核守护进程kerneld的信息分别在include/linux/module.h和include/linux/kerneld.h 中。如果你想看ELF目标文件的结构，它位于include/linux/elf.h中。</p>
<h3 id="Linux系统调用是基于ARMv8的异常模式"><a href="#Linux系统调用是基于ARMv8的异常模式" class="headerlink" title="Linux系统调用是基于ARMv8的异常模式"></a>Linux系统调用是基于ARMv8的异常模式</h3><p>EL0-User，一般的应用程序运行在此级别。</p>
<p>EL1-Suervisor，操作系统运行在此级别，Linux内核，设备驱动等都运行在此级别。</p>
<p>EL2-Hypervisor，虚拟机系统运行在此级别，在此级别Guest客户机的虚拟内存需要做多一层Stage2的地址转换。</p>
<p>EL3-Secure monitor，安全级别。</p>
<p><img src="#" alt="调用级别" title="调用级别"></p>
]]></content>
      <tags>
        <tag>linux源码</tag>
      </tags>
  </entry>
</search>
