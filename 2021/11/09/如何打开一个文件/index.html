<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="LINUX系统调用源码分析关于open函数open函数主要包含以下两类： int open(const char *pathName, int flags); &#x2F;&#x2F; 打开文件int open(const char *pathName, int flags, mode_t mode); &#x2F;&#x2F; 创建文件open函数做了两件事：将用户进程 task_struct（进程结构） 中的filp[20] 与内核">
<meta property="og:type" content="article">
<meta property="og:title" content="使用场景分析--打开文件">
<meta property="og:url" content="http://example.com/2021/11/09/%E5%A6%82%E4%BD%95%E6%89%93%E5%BC%80%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6/index.html">
<meta property="og:site_name" content="Spiritual Time House">
<meta property="og:description" content="LINUX系统调用源码分析关于open函数open函数主要包含以下两类： int open(const char *pathName, int flags); &#x2F;&#x2F; 打开文件int open(const char *pathName, int flags, mode_t mode); &#x2F;&#x2F; 创建文件open函数做了两件事：将用户进程 task_struct（进程结构） 中的filp[20] 与内核">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2021/11/pics/flip.png">
<meta property="og:image" content="http://example.com/2021/11/09/%E5%A6%82%E4%BD%95%E6%89%93%E5%BC%80%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6/index.html#">
<meta property="article:published_time" content="2021-11-09T02:18:06.000Z">
<meta property="article:modified_time" content="2021-11-10T07:18:06.000Z">
<meta property="article:author" content="coldprince">
<meta property="article:tag" content="linux源码">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2021/11/pics/flip.png">

<link rel="canonical" href="http://example.com/2021/11/09/%E5%A6%82%E4%BD%95%E6%89%93%E5%BC%80%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>使用场景分析--打开文件 | Spiritual Time House</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Spiritual Time House</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/mastercoldprince" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/09/%E5%A6%82%E4%BD%95%E6%89%93%E5%BC%80%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="coldprince">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Spiritual Time House">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          使用场景分析--打开文件
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-11-09 10:18:06" itemprop="dateCreated datePublished" datetime="2021-11-09T10:18:06+08:00">2021-11-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-11-10 15:18:06" itemprop="dateModified" datetime="2021-11-10T15:18:06+08:00">2021-11-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="LINUX系统调用源码分析"><a href="#LINUX系统调用源码分析" class="headerlink" title="LINUX系统调用源码分析"></a>LINUX系统调用源码分析</h1><h3 id="关于open函数"><a href="#关于open函数" class="headerlink" title="关于open函数"></a>关于open函数</h3><p>open函数主要包含以下两类：</p>
<p>int open(const char *pathName, int flags); // 打开文件<br>int open(const char *pathName, int flags, mode_t mode); <em>// 创建文件</em><br>open函数做了两件事：<br>将用户进程 task_struct（进程结构） 中的filp[20] 与内核中的file_table[64] 进行挂接。<br>将用户进程需要打开的文件对应的inode节点在file_table[64] 中进行登记。</p>
<ul>
<li>操作系统根据用户进程的需求来操作文件，内核通过 *filp[20] 掌控每一个进程可以打开的文件，既可以打开多个不同的文件，也可以多次打开同一个文件，每打开一次文件（不论是否是同一个文件），就要在 *filp[20] 占用一个项记录指针，所以每一个进程可以同时打开文件的次数不能超过20次；</li>
<li>操作系统中的file_table[64] 是管理所有进程打开文件的数据结构， 不但记录了不同进程打开不同的文件，也记录了不同进程打开同一个文件，甚至记录了同一个进程多次打开一个文件。与filp[20] 类似，只要打开一次文件，就要在file_table[64] 中记录；</li>
<li>文件中的i节点是记载文件属性的最关键的数据结构，在操作系统中i节点和文件是一一对应的，找到i节点，就意味着找到唯一的文件。内核通过inode_table[32] 掌控正在使用的文件i节点，每个被使用的文件i节点都要记录在其中。</li>
</ul>
<p>*<em>打开文件的本质就是要建立 <em>filp[20] file_table[64] inode_table[32] 三者之间的关系。</em></em></p>
<p><img src="../../pics/flip.png" alt="关系" title="关系"></p>
<h3 id="关于打开文件"><a href="#关于打开文件" class="headerlink" title="关于打开文件"></a>关于打开文件</h3><p>Linux中打开文件是通过open系统调用实现，其函数中调用了do_sys_open()函数完成打开功能，首先先看下open系统调用的入口函数，再具体看do_sys_open()函数：</p>
<p>SYSCALL_DEFINE3(open, const char __user *, filename, int, flags, int, mode)</p>
<p>{<br>         long ret;</p>
<pre><code>     if (force_o_largefile())
               flags |= O_LARGEFILE;

     ret = do_sys_open(AT_FDCWD, filename, flags, mode);
     /* avoid REGPARM breakage on x86: */
     asmlinkage_protect(3, ret, filename, flags, mode);
     return ret;
</code></pre>
<p>}</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">do_sys_open</span><span class="params">(<span class="keyword">int</span> dfd, <span class="keyword">const</span> <span class="keyword">char</span> __user *filename, <span class="keyword">int</span> flags, <span class="keyword">int</span> mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*获取文件名称，由getname()函数完成，其内部首先创建存取文件名称的空间，然后*从用户空间把文件名拷贝过来*/</span></span><br></pre></td></tr></table></figure>

<pre><code>     char *tmp = getname(filename);
     int fd = PTR_ERR(tmp);

     if (!IS_ERR(tmp)) &#123;
</code></pre>
<p>/<em>获取一个可用的fd，此函数调用alloc_fd()函数从fd_table中获取一个可用fd,并做些简单初始化，此函数内部实现比较简单，此次分析不细看</em>/</p>
<pre><code>               fd = get_unused_fd_flags(flags);
               if (fd &gt;= 0) &#123;
</code></pre>
<p>/<em>fd获取成功则开始打开文件，此函数是主要完成打开功能的函数</em>/</p>
<pre><code>                        struct file *f = do_filp_open(dfd, tmp, flags, mode, 0);
                        if (IS_ERR(f)) &#123;
                                 /*打开失败，释放fd*/
                                 put_unused_fd(fd);
                                 fd = PTR_ERR(f);
                        &#125; else &#123;
                                 /*文件如果已经被打开了，调用fsnotify_open()函数*/
                                 fsnotify_open(f-&gt;f_path.dentry);
                                 /*将文件指针安装在fd数组中*/
                                 fd_install(fd, f);
                        &#125;
               &#125;
               /*释放放置从用户空间拷贝过来的文件名的存储空间*/
               putname(tmp);
     &#125;
     return fd;&#125;
</code></pre>
<p>打开功能的真正实现功能的函数do_filp_open()函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct file *<span class="title">do_filp_open</span><span class="params">(<span class="keyword">int</span> dfd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">int</span> open_flag, <span class="keyword">int</span> mode, <span class="keyword">int</span> acc_mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">         <span class="comment">/*改变参数flag的值，具体做法是flag+1*/</span></span><br><span class="line">         <span class="keyword">int</span> flag = open_to_namei_flags(open_flag);</span><br><span class="line">         <span class="keyword">int</span> force_reval = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">         <span class="comment">/*根据__O_SYNC标志来设置O_DSYNC 标志，用以防止恶意破坏程序*/</span></span><br><span class="line">         <span class="keyword">if</span> (open_flag &amp; __O_SYNC)</span><br><span class="line">                   open_flag |= O_DSYNC;</span><br><span class="line">         <span class="comment">/*设置访问权限*/</span></span><br><span class="line">         <span class="keyword">if</span> (!acc_mode)</span><br><span class="line">                   acc_mode = MAY_OPEN | ACC_MODE(open_flag);</span><br><span class="line"> </span><br><span class="line">         <span class="comment">/*根据 O_TRUNC标志设置写权限 */</span></span><br><span class="line">         <span class="keyword">if</span> (flag &amp; O_TRUNC)</span><br><span class="line">                   acc_mode |= MAY_WRITE;</span><br><span class="line"> </span><br><span class="line">         <span class="comment">/* 设置O_APPEND 标志*/</span></span><br><span class="line">         <span class="keyword">if</span> (flag &amp; O_APPEND)</span><br><span class="line">                   acc_mode |= MAY_APPEND;</span><br><span class="line"> </span><br><span class="line">         <span class="comment">/*如果不是创建文件*/</span></span><br><span class="line">         <span class="keyword">if</span> (!(flag &amp; O_CREAT)) &#123;</span><br><span class="line">                   <span class="comment">/*返回特定的file结构体指针*/</span></span><br><span class="line">                   filp = get_empty_filp();</span><br><span class="line"> </span><br><span class="line">                   <span class="keyword">if</span> (filp == <span class="literal">NULL</span>)</span><br><span class="line">                            <span class="keyword">return</span> ERR_PTR(-ENFILE);</span><br><span class="line">                   <span class="comment">/*填充nameidata 结构*/</span></span><br><span class="line">                   nd.intent.open.file = filp;</span><br><span class="line">                   filp-&gt;f_flags = open_flag;</span><br><span class="line">                   nd.intent.open.flags = flag;</span><br><span class="line">                   nd.intent.open.create_mode = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>当内核要访问一个文件的时候，第一步要做的是找到这个文件，而查找文件的过程在vfs里面是由path_lookup或者path_lookup_open函数来完成的。这两个函数将用户传进来的字符串表示的文件路径转换成一个dentry结构，并建立好相应的inode和file结构，将指向file的描述符返回用户。用户随后通过文件描述符，来访问这些数据结构<br>                   error = do_path_lookup(dfd, pathname,</p>
<pre><code>                                           lookup_flags(flag)|LOOKUP_OPEN, &amp;nd);

               if (IS_ERR(nd.intent.open.file)) &#123;

                        if (error == 0) &#123;

                                 error = PTR_ERR(nd.intent.open.file);

                                 /*减少dentry和vsmount得计数*/

                                 path_put(&amp;nd.path);

                        &#125;

               &#125; else if (error)

                        /*如果查找失败则释放一些资源*/

                        release_open_intent(&amp;nd);

               if (error)

                        return ERR_PTR(error);

               goto ok;

     &#125;



     /*到此则是要创建文件*/
</code></pre>
<p>reval:</p>
<pre><code>     /* path-init为查找作准备工作，path_walk真正上路查找，这两个函数联合起来根据一段路径名找到对应的dentry */

     error = path_init(dfd, pathname, LOOKUP_PARENT, &amp;nd);

     if (error)

               return ERR_PTR(error);

     if (force_reval)

               nd.flags |= LOOKUP_REVAL;
</code></pre>
<p>/*这个函数相当重要，就如源代码注释的那样，是整个NFS的名字解析函数，其实也是NFS得以构筑的函数该函数采用一个for循环，对name路径根据目录的层次，一层一层推进，直到终点或失败。在推进的过程中，一步步建立了目录树的dentry和对应的inode */</p>
<pre><code>     error = path_walk(pathname, &amp;nd);

     if (error) &#123;

               if (nd.root.mnt)

                        path_put(&amp;nd.root);

               return ERR_PTR(error);

     &#125;

     if (unlikely(!audit_dummy_context()))

               /*保存inode节点信息*/

               audit_inode(pathname, nd.path.dentry);



     /*父节点信息*/

     error = -EISDIR;

     if (nd.last_type != LAST_NORM || nd.last.name[nd.last.len])

               goto exit_parent;



     error = -ENFILE;

     /*获取文件指针*/

     filp = get_empty_filp();

     if (filp == NULL)

               goto exit_parent;

     /*填充nameidata 结构*/

     nd.intent.open.file = filp;

     filp-&gt;f_flags = open_flag;

     nd.intent.open.flags = flag;

     nd.intent.open.create_mode = mode;

     dir = nd.path.dentry;

     nd.flags &amp;= ~LOOKUP_PARENT;

     nd.flags |= LOOKUP_CREATE | LOOKUP_OPEN;

     if (flag &amp; O_EXCL)

               nd.flags |= LOOKUP_EXCL;

     mutex_lock(&amp;dir-&gt;d_inode-&gt;i_mutex);

     /*从哈希表中查找nd对应的dentry*/

     path.dentry = lookup_hash(&amp;nd);

     path.mnt = nd.path.mnt;
</code></pre>
<p>do_last:</p>
<pre><code>     error = PTR_ERR(path.dentry);

     if (IS_ERR(path.dentry)) &#123;

               mutex_unlock(&amp;dir-&gt;d_inode-&gt;i_mutex);

               goto exit;

     &#125;



     if (IS_ERR(nd.intent.open.file)) &#123;

               error = PTR_ERR(nd.intent.open.file);

               goto exit_mutex_unlock;

     &#125;



     /*如果此dentry结构没有对应的inode节点，说明是无效的，应该创建文件节点 */

     if (!path.dentry-&gt;d_inode) &#123;

               /*write权限是必需的*/

               error = mnt_want_write(nd.path.mnt);

               if (error)

                        goto exit_mutex_unlock;

               /*按照namei格式的flag open*/

               error = __open_namei_create(&amp;nd, &amp;path, flag, mode);

               if (error) &#123;

                        mnt_drop_write(nd.path.mnt);

                        goto exit;

               &#125;

               /*根据nameidata 得到相应的file结构*/

               filp = nameidata_to_filp(&amp;nd);

               /*放弃写权限*/

               mnt_drop_write(nd.path.mnt);

               if (nd.root.mnt)

                        /*计数减一*/

                        path_put(&amp;nd.root);

               if (!IS_ERR(filp)) &#123;

                        error = ima_file_check(filp, acc_mode);

                        if (error) &#123;

                                 fput(filp);

                                 filp = ERR_PTR(error);

                        &#125;

               &#125;

               return filp;

     &#125;



     /*要打开的文件已经存在*/

     mutex_unlock(&amp;dir-&gt;d_inode-&gt;i_mutex);

     /*保存inode节点*/

     audit_inode(pathname, path.dentry);
</code></pre>
<p>/*</p>
<pre><code>     *省略若干flag标志检查代码

     */



     /*路径装化为相应的nameidata 结构*/

     path_to_nameidata(&amp;path, &amp;nd);

     error = -EISDIR;

     /*如果是文件夹*/

     if (S_ISDIR(path.dentry-&gt;d_inode-&gt;i_mode))

               goto exit;
</code></pre>
<p>ok:</p>
<pre><code>     /*检测是否截断文件标志*/

     will_truncate = open_will_truncate(flag, nd.path.dentry-&gt;d_inode);

     if (will_truncate) &#123;

     /*要截断的话就要获取写权限*/

               error = mnt_want_write(nd.path.mnt);

               if (error)

                        goto exit;

     &#125;

     //may_open执行权限检测、文件打开和truncate的操作

     error = may_open(&amp;nd.path, acc_mode, flag);

     if (error) &#123;

               if (will_truncate)

                        mnt_drop_write(nd.path.mnt);

               goto exit;

     &#125;

     filp = nameidata_to_filp(&amp;nd);

     if (!IS_ERR(filp)) &#123;

               error = ima_file_check(filp, acc_mode);

               if (error) &#123;

                        fput(filp);

                        filp = ERR_PTR(error);

               &#125;

     &#125;

     if (!IS_ERR(filp)) &#123;

               if (acc_mode &amp; MAY_WRITE)

                        vfs_dq_init(nd.path.dentry-&gt;d_inode);



               if (will_truncate) &#123;

                        //处理截断

                        error = handle_truncate(&amp;nd.path);

                        if (error) &#123;

                                 fput(filp);

                                 filp = ERR_PTR(error);

                        &#125;

               &#125;

     &#125;

     //安全的放弃写权限

     if (will_truncate)

               mnt_drop_write(nd.path.mnt);

     if (nd.root.mnt)

               path_put(&amp;nd.root);

     return filp;
</code></pre>
<p>exit_mutex_unlock:</p>
<pre><code>     mutex_unlock(&amp;dir-&gt;d_inode-&gt;i_mutex);
</code></pre>
<p>exit_dput:</p>
<pre><code>     path_put_conditional(&amp;path, &amp;nd);
</code></pre>
<p>exit:</p>
<pre><code>     if (!IS_ERR(nd.intent.open.file))

               release_open_intent(&amp;nd);
</code></pre>
<p>exit_parent:</p>
<pre><code>     if (nd.root.mnt)

               path_put(&amp;nd.root);

     path_put(&amp;nd.path);

     return ERR_PTR(error);
</code></pre>
<p>//允许遍历连接文件，则手工找到连接文件对应的文件</p>
<p>do_link:</p>
<pre><code>     error = -ELOOP;

     if (flag &amp; O_NOFOLLOW)

               //不允许遍历连接文件，返回错误

               goto exit_dput;

     /*

      以下是手工找到链接文件对应的文件dentry结构代码

      */

     // 设置查找LOOKUP_PARENT标志

     nd.flags |= LOOKUP_PARENT;

     //判断操作是否安全

     error = security_inode_follow_link(path.dentry, &amp;nd);

     if (error)

               goto exit_dput;

     // 处理符号链接

     error = __do_follow_link(&amp;path, &amp;nd);

     path_put(&amp;path);

     if (error) &#123;

    

               release_open_intent(&amp;nd);

               if (nd.root.mnt)

                        path_put(&amp;nd.root);

               if (error == -ESTALE &amp;&amp; !force_reval) &#123;

                        force_reval = 1;

                        goto reval;

               &#125;

               return ERR_PTR(error);

     &#125;

     nd.flags &amp;= ~LOOKUP_PARENT;

     // 检查最后一段文件或目录名的属性情况

     if (nd.last_type == LAST_BIND)

               goto ok;

     error = -EISDIR;

     if (nd.last_type != LAST_NORM)

               goto exit;

     if (nd.last.name[nd.last.len]) &#123;

               __putname(nd.last.name);

               goto exit;

     &#125;

     error = -ELOOP;

     // 出现回环标志: 循环超过32次

     if (count++==32) &#123;

               __putname(nd.last.name);

               goto exit;

     &#125;

     dir = nd.path.dentry;

     mutex_lock(&amp;dir-&gt;d_inode-&gt;i_mutex);

     // 更新路径的挂接点和dentry

     path.dentry = lookup_hash(&amp;nd);

     path.mnt = nd.path.mnt;

     __putname(nd.last.name);

     goto do_last;
</code></pre>
<p>}</p>
<p>分析完上述主要函数以后，我们来看一下整个打开流程是如何做到的：</p>
<p>在内核中要打开一个文件，首先应该找到这个文件，而查找文件的过程在vfs里面是由do_path_lookup或者path_lookup_open函数来完成的。这两个函数将用户传进来的字符串表示的文件路径转换成一个dentry结构，并建立好相应的inode和file结构，将指向file的描述符返回用户。用户随后通过文件描述符，来访问这些数据结构。</p>
<p>基本函数流程及调用方式如下所示：</p>
<p>打开过程首先是open系统调用访问SYSCALL_DEFINE3函数，然后调用do_sys_open 函数完成主要功能，再调用函数do_filp_open完成主要的打开功能，下面详细看下do_filp_open中调用的do_path_lookup主要过程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">staic <span class="keyword">int</span>  <span class="title">do_path_lookup</span><span class="params">(<span class="keyword">int</span> dfd,<span class="keyword">const</span> <span class="keyword">char</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">*name,<span class="keyword">unsigned</span> <span class="keyword">int</span> flags,strucy nameidata *nd)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">int</span> retval=path_init(dfd,name,flags,nd);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置nd-&gt;root=根路径（绝对地址）或者当前工作目录（相对地址） 。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这一步做完了后，内核会建立一些数据结构（dentry,inode）来初始化查找的起点</span></span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span>(!retval)</span><br><span class="line"></span><br><span class="line">                       retval = path_walk(name,nd);</span><br><span class="line"></span><br><span class="line"><span class="comment">//path_walk,会遍历路径的每一份量，也就是用“/”分隔开的每一部分，</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//最中找到name指向的文件，walk的意思就是walk path的每一个组分（component）</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们进一步看看path_walk</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">path_walk</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name,struct nameidata *nd)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> link_path_walk(name,nd);</span><br><span class="line"></span><br><span class="line"><span class="comment">//path_walk其实相当于直接调用link_path_walk来完成工作</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">link_path_walk的主要工作是有其内部函数__link_path_walk 来完成的</span><br><span class="line"></span><br><span class="line">          result = __link_path_walk(name,nd)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>至此我们转向最重要的代码__link_walk_path,该函数把传进来的字符串name，也就是用户指定的路径，按路径分隔符分解成一系列小的component。比如用户说，我要找/path/to/dest这个文件，那么我们的文件系统就会按path,to,dest一个一个来找，知道最后一个分量是文件或者查找完成。他找的时候，会先用path_init初始化过的根路径去找第一个分量，也就是path。然后用path的dentry-&gt;d_inode去找to，这样循环到最后一个。注意，内核会缓存找到的路径分量，所以往往只有第一次访问一个路径的时候，才会去访问磁盘，后面的访问会直接从缓存里找，下面会看到，很多与页告诉缓存打交道的代码。但不管怎样，第一遍查找总是会访问磁盘的。</p>
<p>static int __link_path_walk(const char *name,strucy</p>
<p>nameidata *nd)</p>
<p>{</p>
<p>}</p>
<p>至此，按照每一个component查找完成之后，就会找到相应的文件，然后相应的打开工作就基本完成了。</p>
<h3 id="关于文件分类"><a href="#关于文件分类" class="headerlink" title="关于文件分类"></a>关于文件分类</h3><ol>
<li><p>系统的启动和初始化<br> 在基于Intel的系统上，当 loadlin.exe 或 LILO把内核装入到内存并把控制权传递给内核时，内核开始启动。关于这一部分，看arch/i386/kernel/head.S ，head.S进行特定结构的设置，然后跳转到init/main.c的main()例程。</p>
</li>
<li><p>内存管理<br> 内存管理的代码主要在/mm，但特定结构的代码在arch/*/mm。缺页中断处理的代码在mm/memory.c ，而内存映射和页高速缓存器的代码在mm/filemap.c。缓冲器高速缓存是在mm/buffer.c 中实现，而交换高速缓存是在mm/swap_state.c 和mm/swapfile.c中实现。</p>
</li>
<li><p>内核<br>  内核中，特定结构的代码在arch/*/kernel，调度程序在kernel/sched.c，fork的代码在kernel/fork.c，task_struct 数据结构在 include/linux/sched.h中。</p>
</li>
<li><p>PCI</p>
<pre><code>PCI 伪驱动程序在 drivers/pci/pci.c ，其定义在include/linux/pci.h。每一种结构都有一些特定的 PCI BIOS 代码， Intel的在arch/alpha/kernel/bios32.c。
</code></pre>
</li>
<li><p>进程间通信<br>所有System V IPC 对象权限都包含在 ipc_perm 数据结构中，这可以在  include/linux/ipc.h中找到。 System V 消息是在 ipc/msg.c中实现, 共享内存在 ipc/shm.c中，信号量在  ipc/sem.c中，管道在 ipc/pipe.c中实现。</p>
</li>
<li><p>中断处理<br> 内核的中断处理代码是几乎所有的微处理器所特有的。中断处理代码在  arch/i386/kernel/irq.c中，其定义子在 include/asm-i386/irq.h中。</p>
</li>
<li><p>设备驱动程序</p>
<pre><code>Linux内核源代码的很多行是设备驱动程序。Linux设备驱动程序的所有源代码都保存在/driver，根据类型可进一步划分为：
</code></pre>
</li>
</ol>
<p>/block<br>     块设备驱动程序如ide(在ide.c)。如果你想看包含文件系统的所有设备是如何被初始化的，你应当看drivers/block/genhd.c中的device_setup()，device_setup()不仅初始化了硬盘，当一个网络安装nfs文件系统时，它也初始化网络。块设备包含了基于IDE和SCSI的设备。</p>
<p>/char<br>       这是看字符设备(如tty，串口及鼠标等)驱动程序的地方。<br>/cdrom<br>        Linux的所有CDROM代码都在这儿，如在这儿可以找到Soundblaster CDROM的驱动程序。注意ide CD的驱动程序是 ide-cd.c，放在drivers/block，SCSI CD的驱动程序是scsi.c，放在drivers/scsi。<br>/pci<br>    这是PCI伪驱动程序的源代码，在这里可以看到PCI子系统是如何被映射和初始化的。<br>/scsi<br>     在这里可以找到所有的SCSI代码及Linux所支持的scsi设备的所有设备驱动程序。<br>/net<br>    在这里可以找到网络设备驱动程序，如DECChip 21040 PCI 以太网驱动程序在tulip.c中。<br>/sound<br>       这是所有声卡驱动程序的所在地。<br>       8.文件系统<br>   EXT2 文件系统的源代码全部在  fs/ext2/ 目录下，而其数据结构的定义在  include/linux/ext2_fs.h, ext2_fs_i.h 及 ext2_fs_sb.h中。 虚拟文件系统的数据结构在 include/linux/fs.h中描述，而代码是在fs/*中。 缓冲区高速缓存与更新内核的守护进程的实现是在 fs/buffer.c中 。<br>       9.网络<br>   网络代码保存在/net中，大部分的include文件在include/net下，BSD套节口代码在net/socket.c中，IP 第4版本的套节口代码在net/ipv4/af_inet.c。一般的协议支持代码(包括sk_buff 处理例程)在net/core下，TCP/IP联网代码在net/ipv4下，网络设备驱动程序在/drivers/net下。<br>    10.模块<br>   内核模块的代码部分在内核中，部分在模块包中，前者全部在kernel/modules.c中，而数据结构和内核守护进程kerneld的信息分别在include/linux/module.h和include/linux/kerneld.h 中。如果你想看ELF目标文件的结构，它位于include/linux/elf.h中。</p>
<h3 id="Linux系统调用是基于ARMv8的异常模式"><a href="#Linux系统调用是基于ARMv8的异常模式" class="headerlink" title="Linux系统调用是基于ARMv8的异常模式"></a>Linux系统调用是基于ARMv8的异常模式</h3><p>EL0-User，一般的应用程序运行在此级别。</p>
<p>EL1-Suervisor，操作系统运行在此级别，Linux内核，设备驱动等都运行在此级别。</p>
<p>EL2-Hypervisor，虚拟机系统运行在此级别，在此级别Guest客户机的虚拟内存需要做多一层Stage2的地址转换。</p>
<p>EL3-Secure monitor，安全级别。</p>
<p><img src="#" alt="调用级别" title="调用级别"></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/linux%E6%BA%90%E7%A0%81/" rel="tag"># linux源码</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/10/21/hello-world/" rel="prev" title="操作指南">
      <i class="fa fa-chevron-left"></i> 操作指南
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/11/09/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/" rel="next" title="文件系统详解">
      文件系统详解 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#LINUX%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">1.</span> <span class="nav-text">LINUX系统调用源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E4%BA%8Eopen%E5%87%BD%E6%95%B0"><span class="nav-number">1.0.1.</span> <span class="nav-text">关于open函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6"><span class="nav-number">1.0.2.</span> <span class="nav-text">关于打开文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E6%96%87%E4%BB%B6%E5%88%86%E7%B1%BB"><span class="nav-number">1.0.3.</span> <span class="nav-text">关于文件分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%98%AF%E5%9F%BA%E4%BA%8EARMv8%E7%9A%84%E5%BC%82%E5%B8%B8%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.0.4.</span> <span class="nav-text">Linux系统调用是基于ARMv8的异常模式</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">coldprince</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">7</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">coldprince</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="/js/local-search.js"></script>













    <div id="pjax">
  

  

  

    </div>
</body>
</html>
